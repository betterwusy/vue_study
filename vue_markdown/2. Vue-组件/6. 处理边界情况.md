

# 6. 处理边界情况

​	这里记录的都是和处理边界情况有关的功能，即一些需要对 Vue 的规则做一些小调整的特殊情况。

不过注意这些功能都是有劣势或危险的场景的。我们会在每个案例中注明，所以当你使用每个功能的时候请稍加留意。



## 1）访问元素&组件

​	在绝大多数情况下，我们最好**不要触达另一个组件实例内部或手动操作 DOM 元素**。

​	不过也确实在一些情况下做这些事情是合适的。

### a.访问根实例 $root

​	在每个 Vue 实例的子组件中，都可以通过  **`$root`**  这个属性来访问根实例。

例如：

```js
// Vue 根实例
new Vue({
  data: {
    foo: 1
  },
  computed: {
    bar: function () { /* ... */ }
  },
  methods: {
    baz: function () { /* ... */ }
  }
})
```

所有的子组件都可以将这个实例作为一个全局 store 来访问或使用。

```js
// 获取根组件的数据
this.$root.foo   // -> 1

// 写入根组件的数据
this.$root.foo = 2

// 访问根组件的计算属性
this.$root.bar

// 调用根组件的方法
this.$root.baz()
```

​		对于 demo 或非常小型的有少量组件的应用来说这是很方便的。

​		不过这个模式扩展到中大型应用来说就不然了。因此在绝大多数情况下，我们强烈推荐使用 [Vuex](https://github.com/vuejs/vuex) 来管理应用的状态。



#### b.访问父组件 $parent

​		和 **`$root`** 类似，**`$parent`** 属性 可以用来从一个子组件访问父组件的实例。

​		它提供了一种机会，可以在后期随时触达父级组件，以替代将数据以 prop 的方式传入子组件的方式。

**在绝大多数情况下，触达父级组件会使得你的应用更难调试和理解，尤其是当你变更了父级组件的数据的时候。**
**当我们稍后回看那个组件的时候，很难找出那个变更是从哪里发起的。**

针对需要向任意更深层级的组件提供上下文信息时推荐**[依赖注入]**



#### c.访问子组件实例或子元素 $refs

​		尽管存在 prop 和事件，有的时候你仍可能需要在 JavaScript 里直接访问一个子组件。

为了达到这个目的，可以通过 **`ref`** 这个 attribute 为子组件赋予一个 ID 引用。

例如：

```html
<base-input ref="usernameInput"></base-input>
```

现在在你已经定义了这个 `ref` 的组件里，你可以使用：

```js
this.$refs.usernameInput
```

来访问这个  `<base-input>`  实例，以便不时之需。比如程序化地从一个父级组件聚焦这个输入框。

该 `<base-input>` 组件内部也可以使用一个类似的 `ref` 提供对内部某个指定元素的访问，例如：

```html
<!-- <base-input> 内部 -->
<input ref="input">
```

```js
// <base-input> 内部
methods:{
  focus(){
    this.$refs.input.focus();
  }
}
```

这样就允许  `<base-input>`  的父级组件通过下面的代码聚焦 `<base-input>` 里的输入框：

```js
this.$refs.usernameInput.focus()  // 调用了子组件<base-input>里的方法
```

**当 `ref` 和 `v-for` 一起使用的时候，你得到的 ref 将会是一个包含了对应数据源的这些子组件的数组。**

`$refs` 只会在组件渲染完成之后生效，并且它们不是响应式的。这仅作为一个用于直接操作子组件的“逃生舱”——你应该避免在模板或计算属性中访问 `$refs`。	

#### d.依赖注入 provide/inject

```html
<google-map>
  <google-map-region v-bind:shape="cityBoundaries">
    <google-map-markers v-bind:places="iceCreamShops"></google-map-markers>
  </google-map-region>
</google-map>
```

在这个组件里，所有 `<google-map>` 的后代都需要访问  `<google-map>`  里的一个 `getMap` 方法，以便知道要跟哪个地图进行交互。

不幸的是，使用 `$parent` 属性无法很好的扩展到更深层级的嵌套组件上。

这也是依赖注入的用武之地，它用到了两个新的实例选项：**`provide` 和 `inject`**。

`provide` 选项允许我们指定我们想要**提供**给后代组件的**数据/方法**。<font color="#d63200">provide 选项应该是一个对象或返回一个对象的函数。</font>

在这个例子中，就是 `<google-map>` 内部的 `getMap` 方法：

```js
// <google-map> 组件内部
provide: function () {
  return {
    getMap: this.getMap
  }
}
```

然后在任何后代组件里，我们都可以使用 `inject` 选项来接收指定的我们想要添加在这个实例上的 property：

```js
// <google-map> 组件的所有后代组件里
inject: ['getMap']
```

相比 `$parent` 来说，这个用法可以让我们在*任意*后代组件中访问 `getMap`，而不需要暴露整个 `<google-map>` 实例。

这允许我们更好的持续研发该组件，而不需要担心我们可能会改变/移除一些子组件依赖的东西。

同时这些组件之间的接口是始终明确定义的，就和 `props` 一样。

实际上，你可以把依赖注入看作一部分“大范围有效的 prop”，除了：

- 祖先组件不需要知道哪些后代组件使用了它提供的 property
- 后代组件不需要知道被注入的 property 来自哪里

```
然而，依赖注入还是有负面影响的。它将你应用程序中的组件与它们当前的组织方式耦合起来，使重构变得更加困难。
同时所提供的 property 是非响应式的。这是出于设计的考虑，因为使用它们来创建一个中心化规模化的数据跟使用 $root 做这件事都是不够好的。
如果你想要共享的这个 property 是你的应用特有的，而不是通用化的，或者如果你想在祖先组件中更新所提供的数据，那么这意味着你可能需要换用一个像 Vuex 这样真正的状态管理方案了。
```



## 2）程序化的事件侦听器 $on/$once/$off

  **`$emit(eventName, [...args]) `**  方法可以用于触发当前实例上的事件，附加参数都会传给监听器回调。

```js
// 注册一个 welcome-button 组件, 组件中点击按钮触发监听的 welcome 事件
Vue.component('welcome-button', {
  template: `
    <button v-on:click="$emit('welcome','hi')">
      Click me to be welcomed
    </button>
  `
})
```

在父组件中监听 welcome 事件，触发时执行 sayHi 方法

```html
<div id="emit-example-simple">
  <welcome-button v-on:welcome="saySomething"></welcome-button>
</div>
```

```js
new Vue({
  el: '#emit-example-simple',
  methods: {
    saySomething: function (message) {
      alert('welcome,' + message)
    }
  }
})
```

现在，你已经知道了 `$emit` 的用法，它可以被 `v-on` 侦听，但是 Vue 实例同时在其事件接口中提供了其它的方法。

我们可以通过 $on 、 $once  、$off 来程序化的处理事件监听器。

换句话说，可以在编译模板中使用 v-on:[事件名称]="执行方法" 的方法来监听事件。

现在也可以在程序中，使用 this.$on('事件名称', ()=>{  //回调函数 }) 的方法来监听事件。

以及 $once / $off 来一次性的监听某个事件，或者取消对某个事件的监听。



### a. $on( event, callback )

- **参数**：

  - `{string | Array<string>} event` (数组只在 2.2.0+ 中支持)
  - `{Function} callback`

- **用法**：

  监听当前实例上的自定义事件。事件可以由 `vm.$emit` 触发。回调函数会接收所有传入事件触发函数的额外参数。

- **示例**：

  ```js
  vm.$on('test', function (msg) {
    console.log(msg)
  })
  vm.$emit('test', 'hi')
  // => "hi"
  ```

### b. $once( event, callback )

- **参数**：

  - `{string} event`
  - `{Function} callback`

- **用法**：

  监听一个自定义事件，但是只触发一次。一旦触发之后，监听器就会被移除。

### c. $off( [event, callback\] )

- **参数**：

  - `{string | Array<string>} event` (只在 2.2.2+ 支持数组)
  - `{Function} [callback]`

- **用法**：

  移除自定义事件监听器。

  - 如果没有提供参数，则移除所有的事件监听器；
  - 如果只提供了事件，则移除该事件所有的监听器；
  - 如果同时提供了事件与回调，则只移除这个回调的监听器。



你通常不会用到这些，但是当你需要在一个组件实例上手动侦听事件时，它们是派得上用场的。

它们也可以用于代码组织工具。例如，你可能经常看到这种集成一个第三方库的模式：

```js
// 一次性将这个日期选择器附加到一个输入框上
// 它会被挂载到 DOM 上。
mounted: function () {
  // Pikaday 是一个第三方日期选择器的库
  this.picker = new Pikaday({
    field: this.$refs.input,
    format: 'YYYY-MM-DD'
  })
},
// 在组件被销毁之前，
// 也销毁这个日期选择器。
beforeDestroy: function () {
  this.picker.destroy()
}
```

这里有两个潜在的问题：

- 它需要在这个组件实例中保存这个 `picker`，如果可以的话最好只有生命周期钩子可以访问到它。这并不算严重的问题，但是它可以被视为杂物。
- 我们的建立代码独立于我们的清理代码，这使得我们比较难于程序化地清理我们建立的所有东西。

你应该通过一个程序化的侦听器解决这两个问题：

```js
mounted: function () {
  var picker = new Pikaday({
    field: this.$refs.input,
    format: 'YYYY-MM-DD'
  })

  this.$once('hook:beforeDestroy', function () {
    picker.destroy()
  })
}
// 创建和销毁日期选择器都在 mounted 函数中，建立代码和清理代码不会独立开来
```

使用了这个策略，我甚至可以让多个输入框元素同时使用不同的 Pikaday，每个新的实例都程序化地在后期清理它自己：

```js
// Vue 实例挂载后，指定 input 的 refName，
// 然后进入处理方法，处理方法中会根据指定的 refName 创建对应的日期选择器并在 Vue 实例销毁前销毁该日期选择器
mounted: function () {
  this.attachDatepicker('startDateInput')
  this.attachDatepicker('endDateInput')
},
methods: {
  attachDatepicker: function (refName) {
    var picker = new Pikaday({
      field: this.$refs[refName],
      format: 'YYYY-MM-DD'
    })

    this.$once('hook:beforeDestroy', function () {
      picker.destroy()
    })
  }
}
```

查阅[这个示例](https://codesandbox.io/s/github/vuejs/vuejs.org/tree/master/src/v2/examples/vue-20-programmatic-event-listeners)可以了解到完整的代码。注意，即便如此，如果你发现自己不得不在单个组件里做很多建立和清理的工作，最好的方式通常还是创建更多的模块化组件。

在这个例子中，我们推荐创建一个可复用的 `<input-datepicker>` 组件。比如：

将 `Pikaday` 这个第三方库封装在一个`<input-datepicker>` 的组件中，让  `<input-datepicker> ` 组件在它的生命周期函数中建立和销毁 `Pikaday` 这个选择器，以此实现封装效果，而不是在每个引用了这个第三方库的地方去手动创建和销毁。



## 3) 循环引用

### a. 递归组件

组件是可以在它们自己的模板中调用自身的。不过它们只能通过 `name` 选项来做这件事：

```js
name: 'unique-name-of-my-component'
```

当你使用 `Vue.component` 全局注册一个组件时，这个全局的 ID 会自动设置为该组件的 `name` 选项。

```js
// 该组件的全局 ID 自动是它的 name: unique-name-of-my-component
Vue.component('unique-name-of-my-component', {
  // ...
})
```

稍有不慎，递归组件就可能导致无限循环：

```js
name: 'stack-overflow',
template: '<div><stack-overflow></stack-overflow></div>'
```

类似上述的组件将会导致“max stack size exceeded”错误，所以请确保递归调用是条件性的 (例如使用一个最终会得到 `false` 的 `v-if`)。



### b. 组件之间的循环引用

假设你需要构建一个文件目录树，像访达或资源管理器那样的。你可能有一个 `<tree-folder>` 组件，模板是这样的：

```html
<p>
  <span>{{ folder.name }}</span>
  <tree-folder-contents :children="folder.children"/>
</p>
```

还有一个 `<tree-folder-contents>` 组件，模板是这样的：

```html
<ul>
  <li v-for="child in children">
    <tree-folder v-if="child.children" :folder="child"/>
    <span v-else>{{ child.name }}</span>
  </li>
</ul>
```

当你仔细观察的时候，你会发现这些组件在渲染树中互为对方的后代*和*祖先——一个悖论！当通过 `Vue.component` 全局注册组件的时候，这个悖论会被自动解开。如果你是这样做的，那么k你可以跳过这里。

然而，如果你使用一个*模块系统*依赖/导入组件，例如通过 webpack 或 Browserify，你会遇到一个错误：

```bash
Failed to mount component: template or render function not defined.
```

为了解释这里发生了什么，我们先把两个组件称为 A 和 B。模块系统发现它需要 A，但是首先 A 依赖 B，但是 B 又依赖 A，但是 A  又依赖  B，如此往复。这变成了一个循环，不知道如何不经过其中一个组件而完全解析出另一个组件。为了解决这个问题，我们需要给模块系统一个点，在那里“A *反正*是需要 B 的，但是我们不需要先解析 B。”

在我们的例子中，把 `<tree-folder>` 组件设为了那个点。我们知道那个产生悖论的子组件是 `<tree-folder-contents>` 组件，所以我们会等到生命周期钩子 `beforeCreate` 时去注册它：

```js
beforeCreate: function () {
  this.$options.components.TreeFolderContents = require('./tree-folder-contents.vue').default
}
```

或者，在本地注册组件的时候，你可以使用 webpack 的异步 `import`：

```js
components: {
  TreeFolderContents: () => import('./tree-folder-contents.vue')
}
```

这样问题就解决了！



## 4) 模板定义的替代品

### a. 内联模板 inline-template

当 `inline-template` 这个特殊的 attribute 出现在一个子组件上时，这个组件将会使用其标签包含的内容作为模板，而不是将这些内容作为组件内的插槽来分发。

并且此时该子组件内的template选项的内容无效，同时这些内容必须有且仅有一个根元素(与<template>模板的规则一样)

这使得模板的撰写工作更加灵活。 	

```html
<my-component inline-template>
  <!-- 这里面的内容不是 my-component 组件的插槽内容 -->
  <!-- 而是 my-component 组件的编译模板 -->
  <div>
    <p>These are compiled as the component's own template.</p>
    <p>Not parent's transclusion content.</p>
  </div>
</my-component>
```

内联模板需要定义在 Vue 所属的 DOM 元素内。

例子：

```html
<!DOCTYPE html>
<html lang="cn">
<head>
  <meta charset="UTF-8">
  <title>Document</title>
  <script src="https://cdn.jsdelivr.net/npm/vue@2/dist/vue.js">
  </script>
</head>
<body>
  <div id="app">
    {{ name }}
    <my-component inline-template>
      <!-- 子组件的模板按以下内容来编译 -->
      <!-- 子组件的 teamplate 选项有内容的话会失效 -->
      <div>
        <!-- 此 name 是子组件的作用域下的 name -->
        {{ name }}  
      </div>
    </my-component>
  </div>
  <script>
    Vue.component('my-component', {
      data() {
        return {
          name: 'name from child'
        }
      },
      template: `<div>
        <p>my-component</p>
        <p>{{ name }}</p>
      </div>`
    })
    const app = new Vue({
      el: '#app',
      data: {
        name: 'name from parent',
      }
    })
  </script>
  <style>
  </style>
</body>
</html>
```
<img src="Vue 组件.assets/截屏2021-10-22 22.43.08.png" alt="截屏2021-10-22 22.43.08" style="zoom: 50%; float:left;" />
```
不过，inline-template 会让模板的作用域变得更加难以理解。(inline-template 内模板的作用域是子组件的作用域)

所以作为最佳实践，请在组件内优先选择 template 选项或 .vue 文件里的一个 <template> 元素来定义模板。
```



### b. X-Template

另一个定义模板的方式是在一个 `<script>` 元素中，并为其带上  ` type="text/x-template"`   ，然后通过一个 id 将模板引用过去。

（还是要用 <component-name></component> 这样的方式把子组件声明到父组件中）

例如：

```html
<script type="text/x-template" id="hello-world-template">
  <p>Hello hello hello</p>
</script>
```

```js
Vue.component('hello-world', {
  template: '#hello-world-template'
})
```

x-template 需要定义在 Vue 所属的 DOM 元素外。

```
这些可以用于模板特别大的 demo 或极小型的应用，但是其它情况下请避免使用，因为这会将模板和该组件的其它定义分离开。
```



## 5) 控制更新

### a. 强制更新

如果你发现你自己需要在 Vue 中做一次强制更新，99.9% 的情况，是你在某个地方做错了事。

你可能还没有留意到[数组](https://cn.vuejs.org/v2/guide/list.html#注意事项)或[对象](https://cn.vuejs.org/v2/guide/list.html#对象变更检测注意事项)的变更检测注意事项，或者你可能依赖了一个未被 Vue 的响应式系统追踪的状态。

然而，如果你已经做到了上述的事项仍然发现在极少数的情况下需要手动强制更新，那么你可以通过 [`$forceUpdate`](https://cn.vuejs.org/v2/api/#vm-forceUpdate) 来做这件事。

**用法**：迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。



### b. 通过 v-once 创建低开销的静态组件

渲染普通的 HTML 元素在 Vue 中是非常快速的，但有的时候你可能有一个组件，这个组件包含了**大量**静态内容。

在这种情况下，你可以在根元素上添加 `v-once` attribute 以确保这些内容只计算一次然后缓存起来，就像这样：

```js
Vue.component('terms-of-service', {
  template: `
    <div v-once>
      <h1>Terms of Service</h1>
      ... a lot of static content ...
    </div>
  `
})
```

```
再说一次，试着不要过度使用这个模式。
当你需要渲染大量静态内容时，极少数的情况下它会给你带来便利，除非你非常留意渲染变慢了，不然它完全是没有必要的——再加上它在后期会带来很多困惑。例如，设想另一个开发者并不熟悉 v-once 或漏看了它在模板中，他们可能会花很多个小时去找出模板为什么无法正确更新。
```



















